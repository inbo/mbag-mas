---
title: "Data controle 2025"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../../output/rapporten/markdown/2025") })
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# set up
library(knitr)
opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  out.width = "100%"
)
opts_knit$set(root.dir = here::here())
```

```{r}
# packages
library(tidyverse)
library(sf)
library(mapview)
library(leaflet)
library(targets)

# Conflicts
conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::select)

# Source
source(here::here("source", "R", "tar_read_sf.R"))

# Paths
mbag_dir <- here::here()
targets_store <- here::here("source", "targets", "data_preparation", "_targets")
```

# Doel

Data preparatie verloopt via een targets pipeline waarbij verschillende stappen elkaar opvolgen.
We maken gebruik van ["dynamic branching"](https://books.ropensci.org/targets/dynamic.html) in de targets pipeline.
Dit is een manier om nieuwe targets te definiëren terwijl de pipeline actief is.
Hierbij wordt een nieuwe target gemaakt voor elk bestand.
Bij het toevoegen van een nieuwe dataset van een jaar, zal de pipeline bijgevolg enkel de berekeningen voor de data van het nieuwe jaar moeten doen en niet opnieuw de berekeningen voor de vorige jaren.

In rapport controleren we ...

1. of deze pipeline de verwachte stappen correct doorloopt
2. of in de finale data, op het einde van de pipeline, onverwachte zaken, uitschieters ... aanwezig zijn
3. of de data klaar zijn voor publicatie op GBIF

We doen dit in dit rapport voor de data van 2025.

# Controle data preparatie pipeline {#controle-pipeline}
## Amersfoord naar Lambert coördinaten (crs_pipeline)

In de eerste stap worden Amersfoord coördinaten naar Lambert coördinaten omgezet.
Dit gebeurt via een functie die op verschillende datasets goed getest is.

## Selectie punten MBAG MAS steekproef (select_sampled_points) {#steekproef}

In de tweede stap selecteren we de punten uit de totale dataset die tot het MBAG MAS steekproef behoren.
Dit gebeurt via een "inner join" wat wil zeggen dat we kunnen nagaan of telpunten uit het steekproef niet bezocht zijn (bewust of onbewust).

```{r}
sample <- tar_read("sample", store = targets_store)

select_sampled_points <- tar_read_sf("select_sampled_points",
                                     store = targets_store) %>%
  filter(jaar == 2025)
```

Welke aantallen hebben we per stratum?

```{r}
# Calculate number of locations we should have
sample %>%
  mutate(stratum = paste(openheid_klasse, sbp, sep = " - ")) %>%
  count(regio, stratum, name = "n_stratum") %>%
  group_by(regio) %>%
  mutate(n_regio = sum(n_stratum)) %>%
  ungroup() %>%
  kable()
```

We kijken of we dezelfde aantallen vinden in de data.

```{r}
# Calculate number of locations in data
sample_visited <- select_sampled_points %>%
  st_drop_geometry() %>%
  distinct(plotnaam, regio, openheid_klasse, sbp)

sample_visited %>%
  mutate(stratum = paste(openheid_klasse, sbp, sep = " - ")) %>%
  count(regio, stratum, name = "n_stratum") %>%
  group_by(regio) %>%
  mutate(n_regio = sum(n_stratum)) %>%
  ungroup() %>%
  kable()
```

> In de Polders zijn inderdaad 6 punten geschrapt. In de Zandstreek 2 punten.

## Selecteer data binnen de telperiodes (select_time_periods) {#time-periods}

We selecteren data binnen de correcte telperiodes.
Er zijn 4 telrondes:

- R1: 1 april - 20 april
- R2: 21 april - 10 mei
- R3: 11 mei - 10 juni
- R4: 21 juni - 15 juli

Verliezen we data indien we filteren binnen deze periodes?
Indien ja, hoeveel en waar?

```{r}
select_time_periods <- tar_read_sf(
  "select_time_periods",
  store = targets_store
) %>%
  filter(jaar == 2025)
```

In totaal vallen `r nrow(select_sampled_points) - nrow(select_time_periods)` waarnemingen buiten de telperiodes.

```{r}
# Calculate difference in number of observations before and after filtering on
# counting periods
obs_per_year <- select_sampled_points %>%
  st_drop_geometry() %>%
  count(regio, jaar)

obs_per_year_filtered <- select_time_periods %>%
  st_drop_geometry() %>%
  count(regio, jaar, name = "n_filtered")

obs_per_year %>%
  full_join(obs_per_year_filtered, by = join_by(regio, jaar)) %>%
  mutate(difference = n - n_filtered) %>%
  kable()
```

**Zandleemstreek**

```{r}
# Which occurrences fall outside periods?
oid_zlm <- select_sampled_points %>%
  st_drop_geometry() %>%
  filter(regio == "Zandleemstreek") %>%
  pull(oid)

oid_zlm_filtered <- select_time_periods %>%
  st_drop_geometry() %>%
  filter(regio == "Zandleemstreek") %>%
  pull(oid)

oid_zlm_diff <- setdiff(oid_zlm, oid_zlm_filtered)

# Count number of observations per location and date
obs_per_date_zlm <- select_sampled_points %>%
  st_drop_geometry() %>%
  filter(regio == "Zandleemstreek",
         oid %in% oid_zlm_diff) %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  count(plotnaam, datum, name = "n_obs") %>%
  arrange(plotnaam, datum)

obs_per_date_zlm %>%
  kable()
```

Deze punten zijn geteld vlak na telronde 4.
Worden deze punten wel ook nog geteld in de correcte periodes?

```{r}
# How many times are these locations counted in valid periods?
obs_per_period_zlm <- select_time_periods %>%
  st_drop_geometry() %>%
  filter(regio == "Zandleemstreek",
         plotnaam %in% unique(obs_per_date_zlm$plotnaam)) %>%
  count(plotnaam, periode_in_jaar, naam = "n_obs") %>%
  group_by(plotnaam) %>%
  mutate(n_periodes = n_distinct(periode_in_jaar)) %>%
  ungroup()

obs_per_period_zlm %>%
  kable()
```

Neen, deze locaties zijn niet in telperiode 4 geteld.

> Behouden we deze data?

Zijn alle telpunten in elke telperiode geteld?

```{r}
select_time_periods %>%
  st_drop_geometry() %>%
  mutate(aantal_periodes = n_distinct(periode_in_jaar), .by = "plotnaam") %>%
  mutate(datum = make_date(jaar, maand, dag)) %>%
  filter(aantal_periodes < 4) %>%
  arrange(aantal_periodes, plotnaam, datum) %>%
  distinct(plotnaam, regio, waarnemer = waarneme, datum, aantal_periodes) %>%
  kable()
```

> Van twee telpunten weten we dat ze vlak na R4 zijn geteld. Wat is er gebeurt bij de andere?

## Herbereken afstand tot telpunt (calculate_obs_distance)

We herberekenen de afstand van de waarnemingen tot elk telpunt.
Grote verschillen kunnen wijzen op fouten.

```{r}
calculate_obs_distance <- tar_read_sf(
  "calculate_obs_distance", store = targets_store
) %>%
  filter(jaar == 2025)
```

Zijn er punten waarbij het absolute verschil meer dan 1 m is?

```{r}
# Get original distances
distances_og <- select_time_periods %>%
  st_drop_geometry() %>%
  select(oid, plotnaam, regio, jaar, periode_in_jaar,
         distance2plot_og = distance2plot) %>%
  mutate(distance2plot_og = as.numeric(distance2plot_og))

# Get recalculated distances
distances_new <- calculate_obs_distance %>%
  st_drop_geometry() %>%
  select(oid, plotnaam, regio, jaar, periode_in_jaar,
         distance2plot_new = distance2plot)

# Calculate absolute difference between the two
outlying_distances <- distances_og %>%
  full_join(distances_new,
            by = join_by(oid, plotnaam, regio, jaar, periode_in_jaar)) %>%
  mutate(abs_diff = abs(distance2plot_og - distance2plot_new)) %>%
  filter(abs_diff > 1)

# How many mismatches do we have per region?
outlying_distances
```

Ja, maar dit is o peen zeer grote afstand.
Die zullen in het volgende hoofdstuk bekeken worden.

## Selecteer data binnen telcirkel radius (select_within_radius)

We selecteren data binnen de telcirkels.
Telcirkels hebben een radius van 300 m.
De afstanden krijgen we mee van Sovon, maar worden herberekend.

Verliezen we data indien we filteren binnen deze radius?
Indien ja, hoeveel en waar?

```{r}
select_within_radius <- tar_read_sf(
  "select_within_radius", store = targets_store
) %>%
  filter(jaar == 2025)
```

In totaal vallen `r nrow(calculate_obs_distance) - nrow(select_within_radius)` waarnemingen buiten de telcirkels.

```{r}
# Calculate difference in number of observations before and after filtering on
# radius
obs_per_year <- select_time_periods %>%
  st_drop_geometry() %>%
  count(regio, jaar)

obs_per_year_filtered <- select_within_radius %>%
  st_drop_geometry() %>%
  count(regio, jaar, name = "n_filtered")

obs_per_year %>%
  full_join(obs_per_year_filtered, by = join_by(regio, jaar)) %>%
  mutate(difference = n - n_filtered) %>%
  kable()
```

Het gaat om veel waarnemingen.
We visualiseren deze.

```{r}
# Calculate percentage of outlying observations per location and date
outside_observations <- calculate_obs_distance %>%
  group_by(regio, plotnaam, jaar, periode_in_jaar) %>%
  mutate(max_dist = max(distance2plot)) %>%
  ungroup() %>%
  filter(max_dist > 300) %>%
  mutate(outlier = ifelse(distance2plot > 300, "buiten", "binnen")) %>%
  group_by(regio, plotnaam, jaar, periode_in_jaar) %>%
  mutate(outlier_perc = sum(grepl("buiten", outlier)) / n()) %>%
  ungroup() %>%
  select(regio, plotnaam, jaar, periode_in_jaar, distance2plot,
         outlier, outlier_perc, x_coord, y_coord)

# Get problematic point locations
outside_plots <- outside_observations %>%
  st_drop_geometry() %>%
  distinct(regio, plotnaam, jaar, periode_in_jaar, x_coord, y_coord) %>%
  st_as_sf(coords = c("x_coord", "y_coord"), crs = 31370)

# Get problematic location circles
outside_circles <- outside_plots %>%
  st_buffer(300)

# Visualise outlier percentage distribution
for (reg in sort(unique(outside_observations$regio))) {
  p <- outside_observations %>%
    filter(regio == reg) %>%
    distinct(regio, plotnaam, jaar, periode_in_jaar, outlier_perc) %>%
    ggplot() +
    geom_histogram(aes(x = outlier_perc), bins = 20) +
    coord_cartesian(xlim = c(0, 1)) +
    labs(x = "Procent waarnemingen buiten telcirkel per telling",
         y = "Frequentie",
         title = reg) +
    facet_wrap(~jaar, ncol = 3)
  print(p)
}
```

We stellen dat een verwijdering van > 20% van de waarnemingen per telling op een probleem kan wijzen.
We filteren hierop en kijken wat overblijft.

```{r}
# Filter problematic observations, point locations and circles on outlying
# percentage
outside_observations_new <- outside_observations %>%
  filter(outlier_perc > 0.2)

outside_plots_new <- outside_observations_new %>%
  st_drop_geometry() %>%
  distinct(regio, plotnaam, jaar, periode_in_jaar, x_coord, y_coord) %>%
  st_as_sf(coords = c("x_coord", "y_coord"), crs = 31370)

outside_circles_new <- outside_plots_new %>%
  st_buffer(300)
```

We visualiseren deze punten:

```{r}
# Data preparation
years <- outside_observations_new %>%
  distinct(jaar) %>%
  pull()

# Create an empty leaflet map
leaflet_map <- leaflet() %>%
  addTiles()

# Loop through each year and round, adding layers to the map
for (j in sort(years)) {
  periods <- outside_observations_new %>%
    filter(
      jaar == j
    ) %>%
    distinct(periode_in_jaar) %>%
    pull() %>%
    sort()

  for (ronde in sort(periods)) {
    # Filter data for the current year and round
    circles <- outside_circles_new %>%
      filter(
        jaar == j,
        periode_in_jaar == ronde
      ) %>%
      st_transform(4326)
    plots <- outside_plots_new %>%
      filter(
        jaar == j,
        periode_in_jaar == ronde
      ) %>%
      st_transform(4326)
    observations <- outside_observations_new %>%
      filter(
        jaar == j,
        periode_in_jaar == ronde
      ) %>%
      st_transform(4326)

    # Create title
    title <- paste("Jaar:", j, "- Ronde:", ronde)

    # Add the layers to the leaflet map with group names
    leaflet_map <- leaflet_map %>%
      addPolygons(data = circles, fillOpacity = 0.3, group = title) %>%
      addCircleMarkers(data = plots, radius = 3, color = "black",
                       group = title, label = ~plots$plotnaam) %>%
      addCircleMarkers(data = observations, fillOpacity = 0.8, radius = 5,
                       color = ~ifelse(outlier == "binnen", "green", "red"),
                       group = title, label = ~observations$plotnaam)
  }
}

# Calculate control groups
groups <- outside_observations_new %>%
  distinct(jaar, periode_in_jaar) %>%
  arrange(jaar, periode_in_jaar) %>%
  mutate(group = paste("Jaar:", jaar, "- Ronde:", periode_in_jaar)) %>%
  pull(group)

# Add layer control to toggle visibility of the facets
leaflet_map <- leaflet_map %>%
  addLayersControl(
    overlayGroups = groups,
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    position = "bottomright",
    colors = c("green", "red"),
    labels = c("binnen", "buiten"),
    title = "Locatie t.o.v. telcirkel"
  )

# Print the leaflet map
leaflet_map
```

Bij de meeste punten lijkt dit ok, maar we zien een paar probleempunten:

- Zn_103891.3, R3
  - Lijkt op 2 plaatsen geteld te zijn?
- Zn_102166.5, R3
  - Lijkt op 2 plaatsen geteld te zijn?
- Km_35571.6, R3
  - Lijkt op 2 plaatsen geteld te zijn?
- Pl_14232.4, R4
  - Lijkt op 2 plaatsen geteld te zijn?
- Zn_90455.1, R4
  - Extra waarnemingen op andere locatie?

```{r}
# Problem points
problem_points <- c("Zn_103891.3", "Zn_102166.5", "Km_35571.6", "Pl_14232.4",
                    "Zn_90455.1")

inside_observations_problems <- calculate_obs_distance %>%
  filter(
    (plotnaam == "Zn_103891.3" & periode_in_jaar != "R3") |
      (plotnaam == "Zn_102166.5" & periode_in_jaar != "R3") |
      (plotnaam == "Km_35571.6" & periode_in_jaar != "R3") |
      (plotnaam == "Pl_14232.4" & periode_in_jaar != "R4") |
      (plotnaam == "Zn_90455.1" & periode_in_jaar != "R4")
  ) %>%
  mutate(outlier = "binnen",
         outlier_perc = 0) %>%
  select(all_of(names(outside_observations_new)))

outside_observations_problems <- outside_observations_new %>%
  filter(plotnaam %in% problem_points)

obs_probs_total <- bind_rows(
  inside_observations_problems,
  outside_observations_problems
)

plots_probs_total <- obs_probs_total %>%
  st_drop_geometry() %>%
  distinct(regio, plotnaam, jaar, periode_in_jaar, x_coord, y_coord) %>%
  st_as_sf(coords = c("x_coord", "y_coord"), crs = 31370)

circles_probs_total <- plots_probs_total %>%
  st_buffer(300)

# Data preparation
years <- obs_probs_total %>%
  distinct(jaar) %>%
  pull()

# Create an empty leaflet map
leaflet_map <- leaflet() %>%
  addTiles()

# Loop through each year and round, adding layers to the map
for (j in sort(years)) {
  periods <- obs_probs_total %>%
    filter(plotnaam %in% problem_points,
           jaar == j) %>%
    distinct(periode_in_jaar) %>%
    pull() %>%
    sort()

  for (ronde in sort(periods)) {
    # Filter data for the current year and round
    circles <- circles_probs_total %>%
      filter(plotnaam %in% problem_points,
             jaar == j,
             periode_in_jaar == ronde) %>%
      st_transform(4326)
    plots <- plots_probs_total %>%
      filter(plotnaam %in% problem_points,
             jaar == j,
             periode_in_jaar == ronde) %>%
      st_transform(4326)
    observations <- bind_rows(
      inside_observations_problems,
      outside_observations_problems
    ) %>%
      filter(jaar == j,
             periode_in_jaar == ronde) %>%
      st_transform(4326)

    # Create title
    title <- paste("Jaar:", j, "- Ronde:", ronde)

    # Add the layers to the leaflet map with group names
    leaflet_map <- leaflet_map %>%
      addPolygons(data = circles, fillOpacity = 0.3, group = title) %>%
      addCircleMarkers(data = plots, radius = 3, color = "black",
                       group = title, label = ~plots$plotnaam) %>%
      addCircleMarkers(data = observations, fillOpacity = 0.8, radius = 5,
                       color = ~ifelse(outlier == "binnen", "green", "red"),
                       group = title, label = ~observations$plotnaam)
  }
}

# Calculate control groups
groups <- obs_probs_total %>%
  filter(plotnaam %in% problem_points) %>%
  distinct(jaar, periode_in_jaar) %>%
  arrange(jaar, periode_in_jaar) %>%
  mutate(group = paste("Jaar:", jaar, "- Ronde:", periode_in_jaar)) %>%
  pull(group)

# Add layer control to toggle visibility of the facets
leaflet_map <- leaflet_map %>%
  addLayersControl(
    overlayGroups = groups,
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    position = "bottomright",
    colors = c("green", "red"),
    labels = c("binnen", "buiten"),
    title = "Locatie t.o.v. telcirkel"
  )

# Print the leaflet map
leaflet_map
```

> Wat moet hiermee gebeuren?

## Selecteer soortengroepen (select_species_groups)

Vervolgens selecteren we de data van vogels (soortgrp 2) en zoogdieren (soortgrp 1).

```{r}
select_species_groups <- tar_read_sf(
  "select_species_groups", store = targets_store
) %>%
  filter(jaar == 2025)
```

Is het aantal soortgroepen in de data gelijk aan 2?

```{r}
# Get number of species groups
n_soortgroups <- select_species_groups %>%
  st_drop_geometry() %>%
  distinct(soortgrp) %>%
  nrow()

# Equal to 2 (birds and mammals)?
n_soortgroups == 2
```

Ok.

## Verwerk dubbeltellingen (remove_double_counts)

Sommige telpunten zijn 2x geteld.
We selecteren de telling van de laatste dag binnen de telperiode of de telling gedaan door een professionele teller indien van toepassing.

```{r, echo=FALSE}
# Create table to show professional counters
profs      <-  c("WVNT00", # professional from the start
                 "JJNN16",
                 "NOVN00",
                 "ETBX00")
profs_2022 <-    "RPLT02" # professional after 2022
profs_2023 <- c("KLMS02", # professional after 2023
                "KLMS02",
                "ETON01",
                "BDMR00",
                "DDMR00",
                "PADS02",
                "PCAS00",
                "BOPE01")
profs_2024 <- c("KLMS02", # professional after 2024
                "ETON01",
                "BDMR00",
                "DDMR00",
                "BOPE01",
                "DDMR01",
                "AIST00",
                "MJCS03",
                "TGSS02",
                "WVNN05",
                "BBMS01",
                "WKPN01",
                "RDLK00",
                "ABNS05",
                "IJCS01",
                "DVRN00",
                "JPNS04",
                "LBRH01",
                "RLJE00",
                "ETBX00",
                "LHNN03",
                "SDST00")

data.frame(
  professional = c(
    profs,
    profs_2022,
    profs_2023,
    profs_2024
  ),
  sinds = c(
    rep("vanaf start", length(profs)),
    rep("vanaf 2022", length(profs_2022)),
    rep("vanaf 2023", length(profs_2023)),
    rep("vanaf 2024", length(profs_2024))
  )
) %>%
  kable()
```

```{r}
remove_double_counts <- tar_read_sf(
  "remove_double_counts", store = targets_store
) %>%
  filter(jaar == 2025)

remove_subspecies_names <- tar_read_sf(
  "remove_subspecies_names", store = targets_store
) %>%
  filter(jaar == 2025)
```

We lijsten op waar dubbeltellingen zijn verwijderd.

```{r}
# Get locations with removed observations due to double counting
removed_obs <- select_species_groups %>%
  st_drop_geometry() %>%
  anti_join(st_drop_geometry(remove_double_counts),
            by = join_by(oid, projectid, plotid, plotnaam, x_amersfoord,
                         y_amersfoord, x_lambert, y_lambert, soortgrp, soortnr,
                         naam, aantal, jaar, maand, dag, doy, wrntype,
                         broedcode, opmerk, clterr, clterrid, inplot, periodeid,
                         periode, wrntype_omschrijving, sample_order, batch,
                         regio, area_prop_sb, openheid_klasse, sbp, x_coord,
                         y_coord, crs, datum, periode_in_jaar, distance2plot))

removed_obs %>%
  group_by(regio, plotnaam, jaar) %>%
  summarise(n_periodes = n_distinct(jaar, periode_in_jaar),
            .groups = "drop") %>%
  arrange(regio, plotnaam, jaar) %>%
  kable()
```

Zijn alle dubbeltellingen verwijderd?
In de verwerkte data zou elke locatie maar 1x geteld moeten zijn per periode en jaar.

```{r}
# Calculate number of counts in processed data
remove_subspecies_names %>%
  st_drop_geometry() %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  distinct(regio, plotnaam, jaar, periode_in_jaar, datum) %>%
  count(regio, plotnaam, jaar, periode_in_jaar,
        name = "n_tellingen") %>%
  filter(n_tellingen > 1) %>%
  arrange(regio, plotnaam, jaar) %>%
  nrow() == 0
```

Ok.

**Kempen**

Zijn de juiste tellingen verwijderd?

```{r}
# Which locations are removed?
removed_obs_ol <- removed_obs %>%
  filter(regio == "Kempen") %>%
  distinct(plotnaam, regio, jaar, periode_in_jaar)

# Which observations are removed per date?
removed_obs_ol2 <- removed_obs %>%
  filter(regio == "Kempen") %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  distinct(plotnaam, regio, datum, periode_in_jaar) %>%
  mutate(keep = FALSE)

# Get double counts and look if correct ones are removed
select_species_groups %>%
  st_drop_geometry() %>%
  inner_join(removed_obs_ol,
             by = join_by(plotnaam, jaar, regio, periode_in_jaar)) %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  full_join(removed_obs_ol2,
            by = join_by(plotnaam, regio, datum, periode_in_jaar)) %>%
  mutate(keep = is.na(keep)) %>%
  count(plotnaam, datum, periode_in_jaar, waarnemer = waarneme, keep,
        name = "n_obs") %>%
  arrange(plotnaam, datum, periode_in_jaar) %>%
  kable()
```

- Km_43699.4, R3, CSLO00: ok, laatste telling
- Km_9998.1, R2, SRMS02: ok, voorrang telling professionele teller NOVN00
- Km_9998.1, R3, SRMS02: ok, voorrang telling professionele teller NOVN00

**Oostelijke leemstreek**

Zijn de juiste tellingen verwijderd?

```{r}
# Which locations are removed?
removed_obs_ol <- removed_obs %>%
  filter(regio == "Oostelijke leemstreek") %>%
  distinct(plotnaam, regio, jaar, periode_in_jaar)

# Which observations are removed per date?
removed_obs_ol2 <- removed_obs %>%
  filter(regio == "Oostelijke leemstreek") %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  distinct(plotnaam, regio, datum, periode_in_jaar) %>%
  mutate(keep = FALSE)

# Get double counts and look if correct ones are removed
select_species_groups %>%
  st_drop_geometry() %>%
  inner_join(removed_obs_ol,
             by = join_by(plotnaam, jaar, regio, periode_in_jaar)) %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  full_join(removed_obs_ol2,
            by = join_by(plotnaam, regio, datum, periode_in_jaar)) %>%
  mutate(keep = is.na(keep)) %>%
  count(plotnaam, datum, periode_in_jaar, waarnemer = waarneme, keep,
        name = "n_obs") %>%
  arrange(plotnaam, datum, periode_in_jaar) %>%
  kable()
```

Ja telkens laatste telling behouden.

**Zandleemstreek**

Zijn de juiste tellingen verwijderd?

```{r}
# Which locations are removed?
removed_obs_ol <- removed_obs %>%
  filter(regio == "Zandleemstreek") %>%
  distinct(plotnaam, regio, jaar, periode_in_jaar)

# Which observations are removed per date?
removed_obs_ol2 <- removed_obs %>%
  filter(regio == "Zandleemstreek") %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  distinct(oid, plotnaam, regio, datum, periode_in_jaar) %>%
  mutate(keep = FALSE)

# Get double counts and look if correct ones are removed
select_species_groups %>%
  st_drop_geometry() %>%
  inner_join(removed_obs_ol,
             by = join_by(plotnaam, jaar, regio, periode_in_jaar)) %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  full_join(removed_obs_ol2,
            by = join_by(oid, plotnaam, regio, datum, periode_in_jaar)) %>%
  mutate(keep = is.na(keep)) %>%
  count(plotnaam, datum, periode_in_jaar, waarnemer = waarneme, keep,
        name = "n_obs") %>%
  arrange(plotnaam, datum, periode_in_jaar) %>%
  kable()
```

Ja, professionele tellingen zijn behouden.

**Zandstreek**

Zijn de juiste tellingen verwijderd?

```{r}
# Which locations are removed?
removed_obs_ol <- removed_obs %>%
  filter(regio == "Zandstreek") %>%
  distinct(plotnaam, regio, jaar, periode_in_jaar)

# Which observations are removed per date?
removed_obs_ol2 <- removed_obs %>%
  filter(regio == "Zandstreek") %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  distinct(plotnaam, regio, datum, periode_in_jaar) %>%
  mutate(keep = FALSE)

# Get double counts and look if correct ones are removed
select_species_groups %>%
  st_drop_geometry() %>%
  inner_join(removed_obs_ol,
             by = join_by(plotnaam, jaar, regio, periode_in_jaar)) %>%
  mutate(datum = ymd(paste(jaar, maand, dag, sep = "-"))) %>%
  full_join(removed_obs_ol2,
            by = join_by(plotnaam, regio, datum, periode_in_jaar)) %>%
  mutate(keep = is.na(keep)) %>%
  count(plotnaam, datum, periode_in_jaar, waarnemer = waarneme, keep,
        name = "n_obs") %>%
  arrange(plotnaam, datum, periode_in_jaar) %>%
  kable()
```

Ja, laatste tellingen zijn behouden.

## Verwerk namen van ondersoorten (remove_subspecies_names)

De volgende ondersoorten worden aangepast tot op soortniveau.

```{r, echo=FALSE}
# Create table to show subspecies
data.frame(
  ondersoort = c(
    "gele kwikstaart (spec)",
    "engelse kwikstaart",
    "Noordse Kwikstaart",
    "witte kwikstaart (spec)",
    "Rouwkwikstaart",
    "canadese gans spec.",
    "Witsterblauwborst"
  ),
  soort = c(
    rep("Gele kwikstaart", 3),
    rep("Witte kwikstaart", 2),
    rep("Grote Canadese Gans", 1),
    rep("Blauwborst", 1)
  )
) %>%
  kable()
```

## Telpunten in finale dataset (mas_data_full)

```{r}
mas_data_full <- tar_read("mas_data_full", store = targets_store) %>%
  filter(jaar == 2025)
```

Zijn alle telpunten zijn nog altijd aanwezig?

```{r}
# Show number of locations per stratum
mas_data_full %>%
  st_drop_geometry() %>%
  distinct(plotnaam, regio, openheid_klasse, sbp) %>%
  mutate(stratum = paste(openheid_klasse, sbp, sep = " - ")) %>%
  count(regio, stratum, name = "n_stratum") %>%
  group_by(regio) %>%
  mutate(n_regio = sum(n_stratum)) %>%
  ungroup() %>%
  kable()
```

# Controle finale dataset

Nadat we de pipeline hebben doorlopen bekomen we de finale dataset.
Ook hierop doen we enkele controlestappen.
Zijn alle soorten correct (bv. Blauwe Pauw i.p.v. Blauwe Reiger)? Zijn er opvallend veel individuen opgegeven (bv. 300 i.p.v. 30)? ...

```{r}
mas_data_clean <- tar_read("mas_data_clean", store = targets_store) %>%
  filter(jaar == 2025)
```

## Telpunt- en waarneminglocaties

Zie Sectie \@ref(controle-pipeline).

## Timing observaties

De data bevatten geen info over precieze tijdstippen van tellingen, enkel datums.
De datums werden gecontroleerd in Subsectie \@ref(time-periods).

## Aantal individuen

In sommige gevallen worden meer dan 50 individuen gezien.

```{r}
mas_data_clean %>%
  st_drop_geometry() %>%
  filter(aantal >= 50) %>%
  count(aantal, name = "aantal keer in dataset") %>%
  rename("aantal vogels" = aantal) %>%
  kable()
```

Een opvalllende is ook een uitschieter van 3000 individuen.
We zien dat de meeste waarnemingen wel gaan over soorten die in groep voorkomen, zoals Spreeuw, Grauwe Gans, Roek, Houtduif ...

```{r}
mas_data_clean %>%
  st_drop_geometry() %>%
  select(aantal, naam, plotnaam, waarnemer, datum) %>%
  filter(aantal >= 50) %>%
  arrange(aantal) %>%
  kable()
```

We schrijven deze waarnemingen weg zodat ze toch gecontroleerd kunnen worden.

```{r}
mas_data_clean %>%
  filter(aantal >= 50) %>%
  arrange(aantal) %>%
  write_csv(file.path(mbag_dir, "output", "data_controle",
                      "waarnemingen_met_hoge_aantallen_2025.csv"))
```

## Soortnamen

De volgende soorten werden gezien.
Deze lijst moet gecontroleerd worden op vreemde namen die mogelijks fout zijn.

```{r}
mas_data_clean %>%
  st_drop_geometry() %>%
  count(naam, name =  "aantal waarnemingen") %>%
  arrange(naam) %>%
  kable()
```

## Broedcodes

Broedcodes zijn ook belangrijk voor verdere data analyse.

Communicatie Simon Desmet:

*In de Avimap-versie voor Android kan een teller enkel het aantal wijzigen als de vogel broedcode 0 krijgt, maar met een iPhone is dat wel mogelijk bij vogels die met een hogere broedcode dan 0 ingevoerd werden. Sommige tellers hebben dit blijkbaar effectief gedaan, hoewel wij op voorhand gevraagd hadden dit niet te doen.*

Het is echter moeilijk om deze te controleren.
Wel kunnen we de aantallen visualiseren.

```{r}
mas_data_clean %>%
  st_drop_geometry() %>%
  count(wrntype, wrntype_omschrijving, name = "n_obs") %>%
  rename(
    "broedcode" = wrntype,
    "omschrijving" = wrntype_omschrijving,
  ) %>%
  kable()
```

**Broedcode 1-5**

Er is inderdaad een aantal keer hogere aantallen dan 1 ingevoerd bij broedcodes 1-5.

```{r}
mas_data_full %>%
  st_drop_geometry() %>%
  filter(aantal > 1,
         wrntype > 0) %>%
  count(wrntype, aantal, name = "aantal keer in dataset") %>%
  rename(
    "broedcode" = "wrntype",
    "aantal vogels" = aantal
  ) %>%
  kable()
```

We kijken per jaar hoe vaak een hoger getal dan **2** is geteld voor broedcodes > 0.

```{r}
mas_data_full %>%
  st_drop_geometry() %>%
  filter(aantal > 2,
         wrntype > 0) %>%
  count(wrntype, name = "aantal keer in dataset") %>%
  rename("broedcode" = "wrntype") %>%
  kable()
```

We schrijven de data met broedcodes > 0 met een hoger aantal dan 1 weg.

```{r}
mas_data_clean %>%
  st_drop_geometry() %>%
  filter(aantal > 1,
         wrntype > 0) %>%
  rename("broedcode" = "wrntype") %>%
  select(
    "oid", "plotnaam", "x_lambert", "y_lambert", "datum",
    "periode_in_jaar", "jaar", "naam", "aantal", "broedcode", "waarnemer"
  ) %>%
  arrange(waarnemer, aantal, datum) %>%
  write_csv(file.path(mbag_dir, "output", "data_controle",
                      "hoge_aantallen_broedcodes_2025.csv"))
```

Manueel passen we alle aantallen voor broedcode > 0 manueel aan naar 1.

```{r}
mas_data_clean %>%
  st_drop_geometry() %>%
  filter(aantal > 1,
         wrntype > 0) %>%
  count(wrntype, aantal, name = "aantal keer in dataset") %>%
  rename(
    "broedcode" = "wrntype",
    "aantal vogels" = aantal
  ) %>%
  kable()
```

# Controle data publicatie

taxon_data

> na data controle 2024
